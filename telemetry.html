<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rad.telemetry - rad.typo</title>
    <style>
        :root {
            --bg-color: #fff;
            --text-color: #000;
            --link-color: #0000FF;
            --secondary-color: #666;
            --code-bg: #f5f5f5;
        }

        body {
            font-family: monospace;
            max-width: 800px;
            margin: 48px auto;
            padding: 24px;
            line-height: 1.6;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        h1, h2 {
            margin: 0;
            padding: 0;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 24px;
        }

        h2 {
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: normal;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .header {
            margin-bottom: 30px;
            position: relative;
        }

        .back {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 14px;
        }

        .status {
            color: var(--secondary-color);
            font-size: 14px;
            margin-bottom: 20px;
        }

        .breathing-dots::after {
            content: '';
            animation: breathe 4s infinite;
        }

        @keyframes breathe {
            0%, 100% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
        }

        .card {
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--secondary-color);
        }

        .weather-layout {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 20px;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .metric {
            display: flex;
            flex-direction: column;
        }

        .metric-label {
            color: var(--secondary-color);
            font-size: 13px;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
        }

        .metric-unit {
            font-size: 14px;
            color: var(--secondary-color);
            margin-left: 5px;
        }

        .chart-container {
            width: 100%;
            height: 100%;
            min-height: 180px;
            position: relative;
        }

        .chart-svg {
            width: 100%;
            height: 100%;
        }

        .chart-line {
            fill: none;
            stroke: var(--text-color);
            stroke-width: 2;
        }

        .chart-area {
            fill: var(--text-color);
            opacity: 0.1;
        }

        .chart-grid {
            stroke: var(--secondary-color);
            stroke-width: 0.5;
            opacity: 0.3;
        }

        .chart-label {
            fill: var(--secondary-color);
            font-size: 10px;
            font-family: monospace;
        }

        .footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid var(--secondary-color);
            font-size: 14px;
            color: var(--secondary-color);
        }

        .footer a {
            color: var(--secondary-color);
        }

        @media (max-width: 600px) {
            body { 
                margin: 20px auto;
                padding: 15px;
            }

            .weather-layout {
                grid-template-columns: 1fr;
            }

            .metric-grid {
                grid-template-columns: 1fr;
            }

            .chart-container {
                min-height: 200px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="/" class="back">‚Üê back</a>
        <h1>rad.telemetry</h1>
        <div class="status">derry: <span id="weather-temp">15</span>¬∞C <span id="weather-icon">‚òÅÔ∏è</span> | cpu: <span id="cpu-temp">54</span>¬∞C<span class="breathing-dots"></span></div>
    </header>

    <div class="card">
        <div class="card-header">current weather conditions</div>
        <div class="weather-layout">
            <div class="metric-grid">
                <div class="metric">
                    <div class="metric-label">temperature</div>
                    <div>
                        <span class="metric-value" id="current-temp">--</span>
                        <span class="metric-unit">¬∞C</span>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">feels like</div>
                    <div>
                        <span class="metric-value" id="apparent-temp">--</span>
                        <span class="metric-unit">¬∞C</span>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">humidity</div>
                    <div>
                        <span class="metric-value" id="humidity">--</span>
                        <span class="metric-unit">%</span>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">cloud cover</div>
                    <div>
                        <span class="metric-value" id="cloud-cover">--</span>
                        <span class="metric-unit">%</span>
                    </div>
                </div>
            </div>
            <div class="chart-container">
                <svg id="temp-chart" class="chart-svg" viewBox="0 0 400 180" preserveAspectRatio="xMidYMid meet">
                    <text x="200" y="90" text-anchor="middle" class="chart-label">loading chart...</text>
                </svg>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="card-header">solar & daylight</div>
        <div class="metric-grid">
            <div class="metric">
                <div class="metric-label">sunrise</div>
                <div>
                    <span class="metric-value" id="sunrise">--</span>
                </div>
            </div>
            <div class="metric">
                <div class="metric-label">sunset</div>
                <div>
                    <span class="metric-value" id="sunset">--</span>
                </div>
            </div>
            <div class="metric">
                <div class="metric-label">daylight duration</div>
                <div>
                    <span class="metric-value" id="daylight">--</span>
                    <span class="metric-unit">hrs</span>
                </div>
            </div>
            <div class="metric">
                <div class="metric-label">current solar radiation</div>
                <div>
                    <span class="metric-value" id="solar-radiation">--</span>
                    <span class="metric-unit">W/m¬≤</span>
                </div>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="card-header">system stats</div>
        <div class="weather-layout">
            <div class="metric-grid">
                <div class="metric">
                    <div class="metric-label">cpu temperature</div>
                    <div>
                        <span class="metric-value" id="cpu-temp-card">--</span>
                        <span class="metric-unit">¬∞C</span>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">memory usage</div>
                    <div>
                        <span class="metric-value" id="memory-usage">--</span>
                        <span class="metric-unit">%</span>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">disk usage</div>
                    <div>
                        <span class="metric-value" id="disk-usage">--</span>
                        <span class="metric-unit">%</span>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">uptime</div>
                    <div>
                        <span class="metric-value" id="uptime" style="font-size: 16px;">--</span>
                    </div>
                </div>
            </div>
            <div class="chart-container">
                <svg id="cpu-chart" class="chart-svg" viewBox="0 0 400 180" preserveAspectRatio="xMidYMid meet">
                    <text x="200" y="90" text-anchor="middle" class="chart-label">loading chart...</text>
                </svg>
            </div>
        </div>
    </div>

    <footer class="footer">
        ‚îî‚îÄ <a href="https://radtypo.com/infrastructure.html">infrastructure</a>
    </footer>

    <script>
        // ===================================================================
        // WEATHER DATA
        // ===================================================================
        async function updateWeatherData() {
            try {
                const response = await fetch('https://api.open-meteo.com/v1/forecast?latitude=55.014935&longitude=-7.303231&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,cloud_cover,wind_speed_10m,wind_direction_10m&hourly=shortwave_radiation,temperature_2m&daily=sunrise,sunset,daylight_duration&timezone=Europe/London&forecast_days=1&past_days=1');
                const data = await response.json();
                
                if (data.current) {
                    updateCurrentWeather(data.current);
                }
                
                if (data.daily) {
                    updateSolarData(data.daily);
                }
                
                if (data.hourly) {
                    updateSolarRadiation(data.hourly);
                    drawTemperatureChart(data.hourly.time, data.hourly.temperature_2m);
                }
            } catch (error) {
                console.log('Weather data fetch failed:', error);
            }
        }

        function updateCurrentWeather(current) {
            document.getElementById('current-temp').textContent = Math.round(current.temperature_2m);
            document.getElementById('apparent-temp').textContent = Math.round(current.apparent_temperature);
            document.getElementById('humidity').textContent = current.relative_humidity_2m;
            document.getElementById('cloud-cover').textContent = current.cloud_cover;
            document.getElementById('weather-temp').textContent = Math.round(current.temperature_2m);
            
            const weatherIcons = {
                0: '‚òÄÔ∏è', 3: '‚òÅÔ∏è', 48: 'üå´Ô∏è', 67: 'üåßÔ∏è', 
                77: 'üå®Ô∏è', 82: 'üå¶Ô∏è', 99: '‚õàÔ∏è'
            };
            
            const code = current.weather_code;
            let icon = '‚òÅÔ∏è';
            
            for (const [threshold, emoji] of Object.entries(weatherIcons)) {
                if (code <= parseInt(threshold)) {
                    icon = emoji;
                    break;
                }
            }
            
            document.getElementById('weather-icon').textContent = icon;
        }

        function updateSolarData(daily) {
            const sunrise = new Date(daily.sunrise[0]);
            const sunset = new Date(daily.sunset[0]);
            
            document.getElementById('sunrise').textContent = sunrise.toLocaleTimeString('en-GB', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            document.getElementById('sunset').textContent = sunset.toLocaleTimeString('en-GB', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            const daylightHours = (daily.daylight_duration[0] / 3600).toFixed(1);
            document.getElementById('daylight').textContent = daylightHours;
        }

        function updateSolarRadiation(hourly) {
            if (hourly.shortwave_radiation) {
                const now = new Date();
                const currentHourIndex = now.getHours();
                const radiation = hourly.shortwave_radiation[currentHourIndex] || 0;
                document.getElementById('solar-radiation').textContent = Math.round(radiation);
            }
        }

        // ===================================================================
        // SYSTEM STATS
        // ===================================================================
        async function updateSystemStats() {
            try {
                const response = await fetch('/api/stats.json');
                const data = await response.json();
                
                if (data.thermal && data.thermal.cpu_temp) {
                    const temp = data.thermal.cpu_temp.replace('¬∞C', '');
                    const tempValue = parseFloat(temp);
                    
                    document.getElementById('cpu-temp').textContent = temp;
                    document.getElementById('cpu-temp-card').textContent = temp;
                    
                    storeCpuReading(tempValue);
                    drawCpuChart();
                }
                
                if (data.resources) {
                    const memoryMatch = data.resources.memory.match(/\((\d+)%\)/);
                    if (memoryMatch) {
                        document.getElementById('memory-usage').textContent = memoryMatch[1];
                    }
                    
                    const diskMatch = data.resources.disk.match(/\((\d+)%\)/);
                    if (diskMatch) {
                        document.getElementById('disk-usage').textContent = diskMatch[1];
                    }
                }
                
                if (data.uptime) {
                    document.getElementById('uptime').textContent = data.uptime;
                }
            } catch (error) {
                console.log('System stats fetch failed:', error);
            }
        }

        function storeCpuReading(temp) {
            const now = Date.now();
            let readings = JSON.parse(localStorage.getItem('cpuReadings') || '[]');
            
            readings.push({ time: now, temp: temp });
            
            const oneDayAgo = now - (24 * 60 * 60 * 1000);
            readings = readings.filter(r => r.time > oneDayAgo);
            
            localStorage.setItem('cpuReadings', JSON.stringify(readings));
        }

        // ===================================================================
        // CHART RENDERING
        // ===================================================================
        function drawTemperatureChart(times, temps) {
            const svg = document.getElementById('temp-chart');
            
            if (!temps || temps.length < 2) return;
            
            // Store weather readings with timestamps for consistent time-based display
            const now = Date.now();
            let weatherReadings = JSON.parse(localStorage.getItem('weatherReadings') || '[]');
            
            // Add current batch of readings
            times.forEach((time, i) => {
                const timestamp = new Date(time).getTime();
                // Avoid duplicates
                if (!weatherReadings.find(r => r.time === timestamp)) {
                    weatherReadings.push({ time: timestamp, temp: temps[i] });
                }
            });
            
            // Remove old readings and keep last 24 hours
            const oneDayAgo = now - (24 * 60 * 60 * 1000);
            weatherReadings = weatherReadings
                .filter(r => r.time > oneDayAgo)
                .sort((a, b) => a.time - b.time);
            
            localStorage.setItem('weatherReadings', JSON.stringify(weatherReadings));
            
            // Use stored readings for chart (minimum 2 points)
            if (weatherReadings.length < 2) {
                svg.innerHTML = '<text x="200" y="90" text-anchor="middle" class="chart-label">collecting data...</text>';
                return;
            }
            
            const chartTemps = weatherReadings.map(r => r.temp);
            const minTemp = Math.min(...chartTemps);
            const maxTemp = Math.max(...chartTemps);
            const tempRange = maxTemp - minTemp || 1;
            
            const config = {
                width: 400,
                height: 180,
                padding: { top: 20, right: 20, bottom: 30, left: 40 }
            };
            
            const chartWidth = config.width - config.padding.left - config.padding.right;
            const chartHeight = config.height - config.padding.top - config.padding.bottom;
            
            let svgContent = renderGrid(config, chartHeight, 4);
            const { pathData, areaData } = generatePaths(chartTemps, minTemp, tempRange, config, chartWidth, chartHeight);
            
            svgContent += `<path d="${areaData}" class="chart-area"/>`;
            svgContent += `<path d="${pathData}" class="chart-line"/>`;
            svgContent += renderYAxisLabels(minTemp, maxTemp, config, chartHeight, 4);
            svgContent += renderTimeLabels(weatherReadings, config, chartWidth);
            
            svg.innerHTML = svgContent;
        }

        function drawCpuChart() {
            const readings = JSON.parse(localStorage.getItem('cpuReadings') || '[]');
            
            if (readings.length < 2) return;
            
            const svg = document.getElementById('cpu-chart');
            const temps = readings.map(r => r.temp);
            const minTemp = Math.floor(Math.min(...temps) / 5) * 5;
            const maxTemp = Math.ceil(Math.max(...temps) / 5) * 5;
            const tempRange = maxTemp - minTemp;
            
            const config = {
                width: 400,
                height: 180,
                padding: { top: 20, right: 20, bottom: 30, left: 40 }
            };
            
            const chartWidth = config.width - config.padding.left - config.padding.right;
            const chartHeight = config.height - config.padding.top - config.padding.bottom;
            
            let svgContent = renderGrid(config, chartHeight, 4);
            const { pathData, areaData } = generatePaths(temps, minTemp, tempRange, config, chartWidth, chartHeight);
            
            svgContent += `<path d="${areaData}" class="chart-area"/>`;
            svgContent += `<path d="${pathData}" class="chart-line"/>`;
            svgContent += renderYAxisLabels(minTemp, maxTemp, config, chartHeight, 4);
            svgContent += renderTimeLabels(readings, config, chartWidth);
            
            svg.innerHTML = svgContent;
        }

        // ===================================================================
        // CHART UTILITIES
        // ===================================================================
        function renderGrid(config, chartHeight, divisions) {
            let grid = '';
            for (let i = 0; i <= divisions; i++) {
                const y = config.padding.top + (chartHeight / divisions) * i;
                grid += `<line x1="${config.padding.left}" y1="${y}" x2="${config.width - config.padding.right}" y2="${y}" class="chart-grid"/>`;
            }
            return grid;
        }

        function generatePaths(data, minValue, range, config, chartWidth, chartHeight) {
            let pathData = '';
            let areaData = '';
            
            for (let i = 0; i < data.length; i++) {
                const x = config.padding.left + (chartWidth / (data.length - 1)) * i;
                const normalizedValue = (data[i] - minValue) / range;
                const y = config.padding.top + chartHeight - (normalizedValue * chartHeight);
                
                if (i === 0) {
                    pathData += `M ${x} ${y}`;
                    areaData += `M ${x} ${config.height - config.padding.bottom} L ${x} ${y}`;
                } else {
                    pathData += ` L ${x} ${y}`;
                    areaData += ` L ${x} ${y}`;
                }
            }
            
            areaData += ` L ${config.width - config.padding.right} ${config.height - config.padding.bottom} Z`;
            
            return { pathData, areaData };
        }

        function renderYAxisLabels(minValue, maxValue, config, chartHeight, divisions) {
            let labels = '';
            const range = maxValue - minValue;
            
            for (let i = 0; i <= divisions; i++) {
                const value = minValue + (range / divisions) * (divisions - i);
                const y = config.padding.top + (chartHeight / divisions) * i;
                labels += `<text x="${config.padding.left - 5}" y="${y + 4}" text-anchor="end" class="chart-label">${Math.round(value)}¬∞</text>`;
            }
            
            return labels;
        }

        function renderTimeLabels(readings, config, chartWidth) {
            if (readings.length < 2) return '';
            
            const firstTime = new Date(readings[0].time);
            const lastTime = new Date(readings[readings.length - 1].time);
            const midTime = new Date((readings[0].time + readings[readings.length - 1].time) / 2);
            
            const formatTime = (date) => date.toLocaleTimeString('en-GB', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            return `
                <text x="${config.padding.left}" y="${config.height - config.padding.bottom + 15}" text-anchor="start" class="chart-label">${formatTime(firstTime)}</text>
                <text x="${config.width / 2}" y="${config.height - config.padding.bottom + 15}" text-anchor="middle" class="chart-label">${formatTime(midTime)}</text>
                <text x="${config.width - config.padding.right}" y="${config.height - config.padding.bottom + 15}" text-anchor="end" class="chart-label">${formatTime(lastTime)}</text>
            `;
        }

        // ===================================================================
        // INITIALIZATION
        // ===================================================================
        updateWeatherData();
        updateSystemStats();
        
        setInterval(updateSystemStats, 30000);
        setInterval(updateWeatherData, 300000);
    </script>
</body>
</html>
